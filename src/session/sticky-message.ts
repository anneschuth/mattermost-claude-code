/**
 * Sticky Channel Message module
 *
 * Maintains a "sticky" message at the bottom of the channel that displays
 * an overview of active sessions with links to their threads.
 * The message is updated whenever sessions start or end.
 */

import type { Session } from './types.js';
import type { PlatformClient } from '../platform/index.js';
import type { SessionStore } from '../persistence/session-store.js';

// Store sticky post IDs per platform (in-memory cache)
const stickyPostIds: Map<string, string> = new Map();

// Track if there's been a channel post since last sticky update (per platform)
// If false, we can just update in place instead of delete+recreate
const needsBump: Map<string, boolean> = new Map();

// Mutex to prevent concurrent updates per platform (prevents race conditions)
const updateLocks: Map<string, Promise<void>> = new Map();

// Reference to session store for persistence
let sessionStore: SessionStore | null = null;

/**
 * Initialize the sticky message module with the session store for persistence.
 */
export function initialize(store: SessionStore): void {
  sessionStore = store;

  // Restore sticky post IDs from persistence
  const persistedIds = store.getStickyPostIds();
  for (const [platformId, postId] of persistedIds) {
    stickyPostIds.set(platformId, postId);
  }

  if (persistedIds.size > 0) {
    console.log(`  üìå Restored ${persistedIds.size} sticky post ID(s) from persistence`);
  }
}

/**
 * Format a date as relative time (e.g., "5m ago", "2h ago")
 */
function formatRelativeTime(date: Date): string {
  const now = Date.now();
  const diff = now - date.getTime();
  const minutes = Math.floor(diff / 60000);
  const hours = Math.floor(minutes / 60);

  if (minutes < 1) return 'just now';
  if (minutes < 60) return `${minutes}m ago`;
  if (hours < 24) return `${hours}h ago`;
  return `${Math.floor(hours / 24)}d ago`;
}


/**
 * Extract task progress from session's lastTasksContent.
 * Returns string like "3/7" or null if no tasks.
 */
function getTaskProgress(session: Session): string | null {
  if (!session.lastTasksContent) return null;

  // Parse progress from format: "üìã **Tasks** (3/7 ¬∑ 43%)"
  const match = session.lastTasksContent.match(/\((\d+)\/(\d+)/);
  if (match) {
    return `${match[1]}/${match[2]}`;
  }
  return null;
}

/**
 * Get the display topic for a session.
 * Prefers the dynamic sessionTitle (generated by Claude), falls back to firstPrompt.
 */
function getSessionTopic(session: Session): string {
  // Use Claude-generated title if available
  if (session.sessionTitle) {
    return session.sessionTitle;
  }

  // Fall back to first prompt
  return formatTopicFromPrompt(session.firstPrompt);
}

/**
 * Truncate and clean a prompt for display as a thread topic
 */
function formatTopicFromPrompt(prompt: string | undefined): string {
  if (!prompt) return '_No topic_';

  // Remove @mentions at the start
  let cleaned = prompt.replace(/^@[\w-]+\s*/g, '').trim();

  // Skip bot commands (e.g., !worktree switch, !cd) - these aren't meaningful topics
  if (cleaned.startsWith('!')) {
    return '_No topic_';
  }

  // Remove newlines and collapse whitespace
  cleaned = cleaned.replace(/\s+/g, ' ');

  // Truncate to ~50 chars with ellipsis
  if (cleaned.length > 50) {
    cleaned = cleaned.substring(0, 47) + '‚Ä¶';
  }

  return cleaned || '_No topic_';
}


/**
 * Build the sticky message content showing all active sessions
 */
export function buildStickyMessage(
  sessions: Map<string, Session>,
  platformId: string
): string {
  // Filter sessions for this platform
  const platformSessions = [...sessions.values()].filter(
    s => s.platformId === platformId
  );

  if (platformSessions.length === 0) {
    return [
      '---',
      '**Active Claude Threads**',
      '',
      '_No active sessions_',
      '',
      '_Mention me to start a session_ ¬∑ `npm i -g claude-threads`',
    ].join('\n');
  }

  // Sort by start time (newest first)
  platformSessions.sort((a, b) => b.startedAt.getTime() - a.startedAt.getTime());

  const count = platformSessions.length;
  const lines: string[] = [
    '---',
    `**Active Claude Threads** (${count})`,
    '',
  ];

  for (const session of platformSessions) {
    const topic = getSessionTopic(session);
    const threadLink = `[${topic}](/_redirect/pl/${session.threadId})`;
    const displayName = session.startedByDisplayName || session.startedBy;
    const time = formatRelativeTime(session.startedAt);

    // Build task progress if available (e.g., "3/7")
    const taskProgress = getTaskProgress(session);
    const progressStr = taskProgress ? ` ¬∑ ${taskProgress}` : '';

    lines.push(`‚ñ∏ ${threadLink} ¬∑ **${displayName}**${progressStr} ¬∑ ${time}`);

    // Add description on next line if available
    if (session.sessionDescription) {
      lines.push(`   _${session.sessionDescription}_`);
    }
  }

  lines.push('');
  lines.push('_Mention me to start a session_ ¬∑ `npm i -g claude-threads`');

  return lines.join('\n');
}

const DEBUG = process.env.DEBUG === '1';

/**
 * Update the sticky channel message for a platform.
 * If someone posted in the channel since last update, deletes and recreates at bottom.
 * Otherwise, just updates in place to avoid noise.
 *
 * Uses a mutex to prevent concurrent updates which can cause duplicate sticky posts.
 */
export async function updateStickyMessage(
  platform: PlatformClient,
  sessions: Map<string, Session>
): Promise<void> {
  const platformId = platform.platformId;

  // Wait for any pending update to complete (mutex)
  const pendingUpdate = updateLocks.get(platformId);
  if (pendingUpdate) {
    await pendingUpdate;
  }

  // Create a new lock for this update
  let releaseLock: () => void;
  const lock = new Promise<void>(resolve => { releaseLock = resolve; });
  updateLocks.set(platformId, lock);

  try {
    await updateStickyMessageImpl(platform, sessions);
  } finally {
    releaseLock!();
    updateLocks.delete(platformId);
  }
}

/**
 * Internal implementation of sticky message update.
 */
async function updateStickyMessageImpl(
  platform: PlatformClient,
  sessions: Map<string, Session>
): Promise<void> {
  if (DEBUG) {
    const platformSessions = [...sessions.values()].filter(s => s.platformId === platform.platformId);
    console.log(`[sticky] updateStickyMessage called for ${platform.platformId}, ${platformSessions.length} sessions`);
    for (const s of platformSessions) {
      console.log(`[sticky]   - ${s.sessionId}: title="${s.sessionTitle}" firstPrompt="${s.firstPrompt?.substring(0, 30)}..."`);
    }
  }

  const content = buildStickyMessage(sessions, platform.platformId);
  const existingPostId = stickyPostIds.get(platform.platformId);
  const shouldBump = needsBump.get(platform.platformId) ?? false;

  if (DEBUG) {
    console.log(`[sticky] existingPostId: ${existingPostId || '(none)'}, needsBump: ${shouldBump}`);
    console.log(`[sticky] content preview: ${content.substring(0, 100).replace(/\n/g, '\\n')}...`);
  }

  try {
    // If we have an existing post and no bump is needed, just update in place
    if (existingPostId && !shouldBump) {
      if (DEBUG) console.log(`[sticky] Updating existing post in place...`);
      try {
        await platform.updatePost(existingPostId, content);
        // Re-pin to ensure it stays pinned (defensive - pin status can be lost)
        try {
          await platform.pinPost(existingPostId);
          if (DEBUG) console.log(`[sticky] Re-pinned post`);
        } catch (pinErr) {
          if (DEBUG) console.log(`[sticky] Re-pin failed (might already be pinned):`, pinErr);
        }
        if (DEBUG) console.log(`[sticky] Updated successfully`);
        return;
      } catch (err) {
        // Post might have been deleted, fall through to create new one
        if (DEBUG) console.log(`[sticky] Update failed, will create new:`, err);
      }
    }

    // Reset bump flag
    needsBump.set(platform.platformId, false);

    // Delete existing sticky post if it exists
    if (existingPostId) {
      if (DEBUG) console.log(`[sticky] Unpinning and deleting existing post ${existingPostId.substring(0, 8)}...`);
      try {
        // Unpin first, then delete
        await platform.unpinPost(existingPostId);
        if (DEBUG) console.log(`[sticky] Unpinned successfully`);
      } catch (err) {
        // Post might already be unpinned or deleted, that's fine
        if (DEBUG) console.log(`[sticky] Unpin failed (probably already unpinned):`, err);
      }
      try {
        await platform.deletePost(existingPostId);
        if (DEBUG) console.log(`[sticky] Deleted successfully`);
      } catch (err) {
        // Post might already be deleted, that's fine
        if (DEBUG) console.log(`[sticky] Delete failed (probably already deleted):`, err);
      }
      stickyPostIds.delete(platform.platformId);
    }

    // Create new sticky post at the bottom (no threadId = channel post)
    if (DEBUG) console.log(`[sticky] Creating new post...`);
    const post = await platform.createPost(content);
    stickyPostIds.set(platform.platformId, post.id);

    // Pin the post to keep it visible
    try {
      await platform.pinPost(post.id);
      if (DEBUG) console.log(`[sticky] Pinned post successfully`);
    } catch (err) {
      if (DEBUG) console.log(`[sticky] Failed to pin post:`, err);
    }

    // Persist the new sticky post ID
    if (sessionStore) {
      sessionStore.saveStickyPostId(platform.platformId, post.id);
    }

    console.log(`  üìå Created sticky message for ${platform.platformId}: ${post.id.substring(0, 8)}...`);
  } catch (err) {
    console.error(`  ‚ö†Ô∏è Failed to update sticky message for ${platform.platformId}:`, err);
  }
}

/**
 * Update sticky messages for all platforms.
 * Called whenever sessions change.
 */
export async function updateAllStickyMessages(
  platforms: Map<string, PlatformClient>,
  sessions: Map<string, Session>
): Promise<void> {
  const updates = [...platforms.values()].map(platform =>
    updateStickyMessage(platform, sessions)
  );
  await Promise.all(updates);
}

/**
 * Get the sticky post ID for a platform (for persistence).
 */
export function getStickyPostId(platformId: string): string | undefined {
  return stickyPostIds.get(platformId);
}

/**
 * Set the sticky post ID for a platform (for restoration after restart).
 */
export function setStickyPostId(platformId: string, postId: string): void {
  stickyPostIds.set(platformId, postId);
}

/**
 * Get all sticky post IDs (for persistence).
 */
export function getAllStickyPostIds(): Map<string, string> {
  return new Map(stickyPostIds);
}

/**
 * Restore sticky post IDs from persistence.
 */
export function restoreStickyPostIds(postIds: Map<string, string>): void {
  for (const [platformId, postId] of postIds) {
    stickyPostIds.set(platformId, postId);
  }
}

/**
 * Mark that a platform needs to bump its sticky message to the bottom.
 * Called when someone posts in the channel (not in a thread).
 */
export function markNeedsBump(platformId: string): void {
  needsBump.set(platformId, true);
}

/**
 * Clean up old pinned sticky messages from the bot.
 * Unpins and deletes any pinned posts from the bot except the current sticky.
 * Should be called at startup.
 */
export async function cleanupOldStickyMessages(
  platform: PlatformClient,
  botUserId: string
): Promise<void> {
  const currentStickyId = stickyPostIds.get(platform.platformId);

  try {
    // Get all pinned posts in the channel
    const pinnedPostIds = await platform.getPinnedPosts();
    if (DEBUG) console.log(`[sticky] Found ${pinnedPostIds.length} pinned posts, current sticky: ${currentStickyId?.substring(0, 8) || '(none)'}`);

    for (const postId of pinnedPostIds) {
      // Skip the current sticky
      if (postId === currentStickyId) continue;

      // Get post details to check if it's from the bot
      try {
        const post = await platform.getPost(postId);
        if (!post) continue;

        // Check if this post is from our bot (match user ID)
        // The post's userId should match botUserId if it's ours
        if (post.userId === botUserId) {
          if (DEBUG) console.log(`[sticky] Cleaning up old sticky: ${postId.substring(0, 8)}...`);
          try {
            await platform.unpinPost(postId);
            await platform.deletePost(postId);
            console.log(`  üßπ Cleaned up old sticky message: ${postId.substring(0, 8)}...`);
          } catch (err) {
            if (DEBUG) console.log(`[sticky] Failed to cleanup ${postId}:`, err);
          }
        }
      } catch (err) {
        // Post might be deleted or inaccessible, skip it
        if (DEBUG) console.log(`[sticky] Could not check post ${postId}:`, err);
      }
    }
  } catch (err) {
    console.error(`  ‚ö†Ô∏è Failed to cleanup old sticky messages:`, err);
  }
}
