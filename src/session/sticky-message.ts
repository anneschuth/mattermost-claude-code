/**
 * Sticky Channel Message module
 *
 * Maintains a "sticky" message at the bottom of the channel that displays
 * an overview of active sessions with links to their threads.
 * The message is updated whenever sessions start or end.
 */

import type { Session } from './types.js';
import type { PlatformClient } from '../platform/index.js';
import type { SessionStore } from '../persistence/session-store.js';

// Store sticky post IDs per platform (in-memory cache)
const stickyPostIds: Map<string, string> = new Map();

// Reference to session store for persistence
let sessionStore: SessionStore | null = null;

/**
 * Initialize the sticky message module with the session store for persistence.
 */
export function initialize(store: SessionStore): void {
  sessionStore = store;

  // Restore sticky post IDs from persistence
  const persistedIds = store.getStickyPostIds();
  for (const [platformId, postId] of persistedIds) {
    stickyPostIds.set(platformId, postId);
  }

  if (persistedIds.size > 0) {
    console.log(`  üìå Restored ${persistedIds.size} sticky post ID(s) from persistence`);
  }
}

/**
 * Format a date as relative time (e.g., "5m ago", "2h ago")
 */
function formatRelativeTime(date: Date): string {
  const now = Date.now();
  const diff = now - date.getTime();
  const minutes = Math.floor(diff / 60000);
  const hours = Math.floor(minutes / 60);

  if (minutes < 1) return 'just now';
  if (minutes < 60) return `${minutes}m ago`;
  if (hours < 24) return `${hours}h ago`;
  return `${Math.floor(hours / 24)}d ago`;
}

/**
 * Shorten a directory path for display
 */
function shortenPath(path: string): string {
  // Show last 2 components
  const parts = path.split('/').filter(Boolean);
  if (parts.length <= 2) return path;
  return '‚Ä¶/' + parts.slice(-2).join('/');
}

/**
 * Get the display topic for a session.
 * Prefers the dynamic sessionTitle (generated by Claude), falls back to firstPrompt.
 */
function getSessionTopic(session: Session): string {
  // Use Claude-generated title if available
  if (session.sessionTitle) {
    return session.sessionTitle;
  }

  // Fall back to first prompt
  return formatTopicFromPrompt(session.firstPrompt);
}

/**
 * Truncate and clean a prompt for display as a thread topic
 */
function formatTopicFromPrompt(prompt: string | undefined): string {
  if (!prompt) return '_No topic_';

  // Remove @mentions at the start
  let cleaned = prompt.replace(/^@[\w-]+\s*/g, '').trim();

  // Remove newlines and collapse whitespace
  cleaned = cleaned.replace(/\s+/g, ' ');

  // Truncate to ~50 chars with ellipsis
  if (cleaned.length > 50) {
    cleaned = cleaned.substring(0, 47) + '‚Ä¶';
  }

  return cleaned || '_No topic_';
}


/**
 * Build the sticky message content showing all active sessions
 */
export function buildStickyMessage(
  sessions: Map<string, Session>,
  platformId: string
): string {
  // Filter sessions for this platform
  const platformSessions = [...sessions.values()].filter(
    s => s.platformId === platformId
  );

  if (platformSessions.length === 0) {
    return [
      '### :robot: Claude Code Sessions',
      '',
      '_No active sessions_',
      '',
      'Start a session by mentioning me in a message!',
    ].join('\n');
  }

  // Sort by start time (newest first)
  platformSessions.sort((a, b) => b.startedAt.getTime() - a.startedAt.getTime());

  const lines: string[] = [
    `### :robot: Claude Code Sessions (${platformSessions.length} active)`,
    '',
    '| Topic | Started by | Directory | Started |',
    '|:------|:-----------|:----------|:--------|',
  ];

  for (const session of platformSessions) {
    const topic = getSessionTopic(session);
    const threadLink = `[${topic}](/_redirect/pl/${session.threadId})`;
    const startedBy = `@${session.startedBy}`;
    const workingDir = `\`${shortenPath(session.workingDir)}\``;
    const startedAt = formatRelativeTime(session.startedAt);

    lines.push(`| ${threadLink} | ${startedBy} | ${workingDir} | ${startedAt} |`);
  }

  lines.push('');
  lines.push('_This message updates automatically when sessions start or end._');

  return lines.join('\n');
}

/**
 * Update the sticky channel message for a platform.
 * Deletes the old message and creates a new one at the bottom of the channel
 * to keep it "sticky" at the bottom.
 */
export async function updateStickyMessage(
  platform: PlatformClient,
  sessions: Map<string, Session>
): Promise<void> {
  const content = buildStickyMessage(sessions, platform.platformId);
  const existingPostId = stickyPostIds.get(platform.platformId);

  try {
    // Delete existing sticky post if it exists
    if (existingPostId) {
      try {
        await platform.deletePost(existingPostId);
      } catch {
        // Post might already be deleted, that's fine
      }
      stickyPostIds.delete(platform.platformId);
    }

    // Create new sticky post at the bottom (no threadId = channel post)
    const post = await platform.createPost(content);
    stickyPostIds.set(platform.platformId, post.id);

    // Persist the new sticky post ID
    if (sessionStore) {
      sessionStore.saveStickyPostId(platform.platformId, post.id);
    }

    console.log(`  üìå Created sticky message for ${platform.platformId}: ${post.id.substring(0, 8)}...`);
  } catch (err) {
    console.error(`  ‚ö†Ô∏è Failed to update sticky message for ${platform.platformId}:`, err);
  }
}

/**
 * Update sticky messages for all platforms.
 * Called whenever sessions change.
 */
export async function updateAllStickyMessages(
  platforms: Map<string, PlatformClient>,
  sessions: Map<string, Session>
): Promise<void> {
  const updates = [...platforms.values()].map(platform =>
    updateStickyMessage(platform, sessions)
  );
  await Promise.all(updates);
}

/**
 * Get the sticky post ID for a platform (for persistence).
 */
export function getStickyPostId(platformId: string): string | undefined {
  return stickyPostIds.get(platformId);
}

/**
 * Set the sticky post ID for a platform (for restoration after restart).
 */
export function setStickyPostId(platformId: string, postId: string): void {
  stickyPostIds.set(platformId, postId);
}

/**
 * Get all sticky post IDs (for persistence).
 */
export function getAllStickyPostIds(): Map<string, string> {
  return new Map(stickyPostIds);
}

/**
 * Restore sticky post IDs from persistence.
 */
export function restoreStickyPostIds(postIds: Map<string, string>): void {
  for (const [platformId, postId] of postIds) {
    stickyPostIds.set(platformId, postId);
  }
}
